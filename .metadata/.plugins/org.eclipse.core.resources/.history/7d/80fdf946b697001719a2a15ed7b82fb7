package l03.controller;

import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.cli.CommandLine;
import org.apache.pdfbox.pdmodel.PDDocument;

import technology.tabula.CommandLineApp;
import technology.tabula.ObjectExtractor;
import technology.tabula.Page;
import technology.tabula.PageIterator;
import technology.tabula.Rectangle;
import technology.tabula.Table;
import technology.tabula.Utils;
import technology.tabula.detectors.DetectionAlgorithm;
import technology.tabula.detectors.NurminenDetectionAlgorithm;
import technology.tabula.extractors.BasicExtractionAlgorithm;
import technology.tabula.extractors.SpreadsheetExtractionAlgorithm;
import technology.tabula.writers.CSVWriter;
import technology.tabula.writers.JSONWriter;
import technology.tabula.writers.TSVWriter;
import technology.tabula.writers.Writer;

public class TabulaController {


	private Appendable defaultOutput;
	private Rectangle pageArea;
	private List<Integer> pages;
	private OutputFormat outputFormat;
	private String password;
	private TableExtractor tableExtractor;

	public static void main(String[] args) {


	}



	private void extractFile(File pdfFile, Appendable outFile) throws ParseException {
		PDDocument pdfDocument = null;
		try {
			PageIterator pageIterator = getPageIterator(pdfDocument);
			List<Table> tables = new ArrayList<Table>();

			while (pageIterator.hasNext()) {
				Page page = pageIterator.next();

				if (pageArea != null) {
					page = page.getArea(pageArea);
				}

				tables.addAll(tableExtractor.extractTables(page));
			}
			writeTables(tables, outFile);
		} catch (IOException e) {
			throw new ParseException(e.getMessage(), 0);
		} finally {
			try {
				if (pdfDocument != null) {
					pdfDocument.close();
				}
			} catch (IOException e) {
				System.out.println("Error in closing pdf document" + e);
			}
		}
	}

	private PageIterator getPageIterator(PDDocument pdfDocument) throws IOException {
		ObjectExtractor extractor = new ObjectExtractor(pdfDocument);
		return (pages == null) ?
				extractor.extract() :
					extractor.extract(pages);
	}

	// CommandLine parsing methods

	private static OutputFormat whichOutputFormat(CommandLine line) throws ParseException {
		if (!line.hasOption('f')) {
			return OutputFormat.CSV;
		}

		try {
			return OutputFormat.valueOf(line.getOptionValue('f'));
		} catch (IllegalArgumentException e) {
			throw new ParseException(String.format(
					"format %s is illegal. Available formats: %s",
					line.getOptionValue('f'),
					Utils.join(",", OutputFormat.formatNames())), 0);
		}
	}

	private static Rectangle whichArea(CommandLine line) throws ParseException {
		if (!line.hasOption('a')) {
			return null;
		}

		List<Float> f = parseFloatList(line.getOptionValue('a'));
		if (f.size() != 4) {
			throw new ParseException("area parameters must be top,left,bottom,right", 0);
		}
		return new Rectangle(f.get(0), f.get(1), f.get(3) - f.get(1), f.get(2) - f.get(0));
	}

	private static List<Integer> whichPages(CommandLine line) throws ParseException, Exception {
		String pagesOption = line.hasOption('p') ? line.getOptionValue('p') : "1";
		return Utils.parsePagesOption(pagesOption);
	}
	
	public static List<Float> parseFloatList(String option) throws ParseException {
        String[] f = option.split(",");
        List<Float> rv = new ArrayList<Float>();
        try {
            for (int i = 0; i < f.length; i++) {
                rv.add(Float.parseFloat(f[i]));
            }
            return rv;
        } catch (NumberFormatException e) {
            throw new ParseException("Wrong number syntax", 0);
        }
}

	private static TableExtractor createExtractor(CommandLine line) throws ParseException {
		TableExtractor extractor = new TableExtractor();
		extractor.setGuess(line.hasOption('g'));
		extractor.setMethod(CommandLineApp.whichExtractionMethod(line));
		extractor.setUseLineReturns(line.hasOption('u'));

		if (line.hasOption('c')) {
			extractor.setVerticalRulingPositions(parseFloatList(line.getOptionValue('c')));
		}
		return extractor;

	}
	private static class TableExtractor {
		private boolean guess = false;
		private boolean useLineReturns = false;
		private BasicExtractionAlgorithm basicExtractor = new BasicExtractionAlgorithm();
		private SpreadsheetExtractionAlgorithm spreadsheetExtractor = new SpreadsheetExtractionAlgorithm();
		private List<Float> verticalRulingPositions = null;
		private ExtractionMethod method = ExtractionMethod.BASIC;

		public TableExtractor() {
		}

		public void setVerticalRulingPositions(List<Float> positions) {
			this.verticalRulingPositions = positions;
		}

		public void setGuess(boolean guess) {
			this.guess = guess;
		}

		public void setUseLineReturns(boolean useLineReturns) {
			this.useLineReturns = useLineReturns;
		}

		public void setMethod(ExtractionMethod method) {
			this.method = method;
		}

		public List<Table> extractTables(Page page) {
			ExtractionMethod effectiveMethod = this.method;
			if (effectiveMethod == ExtractionMethod.DECIDE) {
				effectiveMethod = spreadsheetExtractor.isTabular(page) ?
						ExtractionMethod.SPREADSHEET :
							ExtractionMethod.BASIC;
			}
			switch (effectiveMethod) {
			case BASIC:
				return extractTablesBasic(page);
			case SPREADSHEET:
				return extractTablesSpreadsheet(page);
			default:
				return new ArrayList<Table>();
			}
		}

		public List<Table> extractTablesBasic(Page page) {
			if (guess) {
				// guess the page areas to extract using a detection algorithm
				// currently we only have a detector that uses spreadsheets to find table areas
				DetectionAlgorithm detector = new NurminenDetectionAlgorithm();
				List<Rectangle> guesses = detector.detect(page);
				List<Table> tables = new ArrayList<Table>();

				for (Rectangle guessRect : guesses) {
					Page guess = page.getArea(guessRect);
					tables.addAll(basicExtractor.extract(guess));
				}
				return tables;
			}

			if (verticalRulingPositions != null) {
				return basicExtractor.extract(page, verticalRulingPositions);
			}
			return basicExtractor.extract(page);
		}

		public List<Table> extractTablesSpreadsheet(Page page) {
			// TODO add useLineReturns
			return (List<Table>) spreadsheetExtractor.extract(page);
		}
	}

	private void writeTables(List<Table> tables, Appendable out) throws IOException {
		Writer writer = null;
		switch (outputFormat) {
		case CSV:
			writer = new CSVWriter();
			break;
		case JSON:
			writer = new JSONWriter();
			break;
		case TSV:
			writer = new TSVWriter();
			break;
		}
		writer.write(out, tables);
	}

	private String getOutputFilename(File pdfFile) {
		String extension = ".csv";
		switch (outputFormat) {
		case CSV:
			extension = ".csv";
			break;
		case JSON:
			extension = ".json";
			break;
		case TSV:
			extension = ".tsv";
			break;
		}
		return pdfFile.getPath().replaceFirst("(\\.pdf|)$", extension);
	}

	private enum OutputFormat {
		CSV,
		TSV,
		JSON;

		static String[] formatNames() {
			OutputFormat[] values = OutputFormat.values();
			String[] rv = new String[values.length];
			for (int i = 0; i < values.length; i++) {
				rv[i] = values[i].name();
			}
			return rv;
		}
	}
}
